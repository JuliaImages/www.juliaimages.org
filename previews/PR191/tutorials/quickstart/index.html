<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart · JuliaImages</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaImages logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaImages</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Quickstart</a><ul class="internal"><li><a class="tocitem" href="#Images-are-just-arrays"><span>Images are just arrays</span></a></li><li><a class="tocitem" href="#Array-elements-are-pixels-(and-vice-versa)"><span>Array elements are pixels (and vice versa)</span></a></li><li><a class="tocitem" href="#Color-conversions-are-construction/view"><span>Color conversions are construction/view</span></a></li><li><a class="tocitem" href="#The-0-to-1-intensity-scale"><span>The 0-to-1 intensity scale</span></a></li><li><a class="tocitem" href="#Arrays-with-arbitrary-indices"><span>Arrays with arbitrary indices</span></a></li><li><a class="tocitem" href="#Function-categories"><span>Function categories</span></a></li></ul></li><li><a class="tocitem" href="../arrays_colors/">Arrays, Numbers, and Colors</a></li><li><a class="tocitem" href="../conversions_views/">Conversions vs. views</a></li><li><a class="tocitem" href="../indexing/">Arrays: more advanced indexing</a></li></ul></li><li><span class="tocitem">Packages</span><ul><li><a class="tocitem" href="../../pkgs/">Introduction</a></li><li><a class="tocitem" href="../../pkgs/axes/">ImageAxes.jl</a></li><li><a class="tocitem" href="../../pkgs/metadata/">ImageMetaData.jl</a></li><li><a class="tocitem" href="../../pkgs/segmentation/">ImageSegmentation.jl</a></li><li><a class="tocitem" href="../../pkgs/transformations/">ImageTransformations.jl</a></li><li><a class="tocitem" href="../../pkgs/features/">ImageFeatures.jl</a></li></ul></li><li><a class="tocitem" href="../../examples/">Demos</a></li><li><a class="tocitem" href="../../function_reference/">References</a></li><li><a class="tocitem" href="../../api_comparison/">Comparison with other image processing frameworks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Quickstart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/juliaimages.github.io/blob/source/docs/src/tutorials/quickstart.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="page_quickstart"><a class="docs-heading-anchor" href="#page_quickstart">Quickstart</a><a id="page_quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#page_quickstart" title="Permalink"></a></h1><p>If you&#39;re comfortable with Julia or have used another image-processing package before, this page may help you get started quickly. If some of the terms or concepts here seem strange, don&#39;t worry–-there are much more detailed explanations in the following sections.</p><h2 id="Images-are-just-arrays"><a class="docs-heading-anchor" href="#Images-are-just-arrays">Images are just arrays</a><a id="Images-are-just-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Images-are-just-arrays" title="Permalink"></a></h2><p>For most purposes, any <code>AbstractArray</code> can be treated as an image. For example, numeric array can be interpreted as a grayscale image.</p><pre><code class="language-julia-repl">julia&gt; img = rand(4, 3)
4×3 Matrix{Float64}:
 0.294863  0.603624   0.113032
 0.696311  0.0443766  0.670174
 0.332355  0.915681   0.140473
 0.415085  0.372323   0.0813266</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAB0CAAAAADVm/EoAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAANhJREFUaAW1wTERwgAABMErzgJqkEBBjYI4wECMZAZfeMABDr67XR8MT4aTQRrSkIY0pCENaUhDGtKQhjSkIQ1pSEMa0pCGNKQhDWlIQxrSkIY0PBheDBeDNKQhDWlIQxrSkIY0pCENaUhDGtKQhjSkIQ1pSEMa0pCGNKQhDWn4Yfgy3BmkIQ1pSEMa0pCGNKQhDWlIQxrSkIY0pCENaUhDGtKQhjSkIQ1pSMMbw5vhxyANaUhDGtKQhjSkIQ1pSEMa0pCGNKQhDWlIQxrSkIY0pCENaUhDGn/DLweGhsVNIQAAAABJRU5ErkJggg==" /><p>We could also select a region-of-interest from a larger image</p><pre><code class="language-julia"># generate an image that starts black in the upper left
# and gets bright in the lower right
img = Array(reshape(range(0,stop=1,length=10^4), 100, 100))
# make a copy
img_c = img[51:70, 21:70] # red
# make a view
img_v = @view img[16:35, 41:90] # blue</code></pre><img src="data:image/png;base64,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" /><p>As you might know, changing the value of a view would affect the original image, while changing that of a copy doesn&#39;t:</p><pre><code class="language-julia">fill!(img_c, 1) # red region in original doesn&#39;t change
fill!(img_v, 0) # blue</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAB4CAIAAACLlMDjAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAABGxJREFUeAHtweFxXgcVRdG9z7mTjiCUQaoILUEd0AMZUkcogh8ivBkP9tiy3ncVxZ+kt9ZwOW2AtknaJmmbpG2SHpK0TdI2SdskbZP0kKRtkrZJ2ibpIUnbJG2TtE3SNkkPSdomaZukbZIekrRN0jZJ2yRtk/SQpG2StknaJukhSdskbZO0TdI2SQ9J2iZpm6Rtkh6StE3SNknbJG2/++67YUtlS2VLZUvlGYbLacMjVLZUtlS2VLZUnjJcnqJyGG6nsqWypbKl8mzDu6dyzvAZlS2VLZUtlZc3XB6n8pHhFipbKlsqWyq/keEdU7nF8BGVLZUtlS2V38vwdqlsqXxmOEdlS2VL5W4M38jf/vZX7s8vv/ybxw0HlS2VJbkvD3zVcPmUyiOGp6hsqbwhw+W04RlU3pPhctrwOJUtlTdnuJygAsOKypbK6zRcThu+RGVL5Y0aLl+l8sFwI5UtlddsuJw2fEplS+VNGy6PUPnUcJrKlsrrN1xOGz5Q2VLZeOBVGV6Yypf8+ONfkvSQpG2StknaJukhSdskbZO0TdI2SQ9J2iZpm6Rtkh6StE3SNknbJG2T9JCkbZK2SdpCAJUvGU5QucDw7ahsqWyprAygsqXybgwvRmVLZUtlS+Vxw1epXD4YtlS2VLZUtlSeYbicNrwAlS2VLZUtlacMj1C5fGq4ncqWypbKlsqWymG4nDZ8RmVLZUtlS2VL5ZzhctpwC5UtlS2VLZUtlY8Mz/Cvn3/m/vzj73/nZQwfUbnRn77/PkkPSdomaZukbZK2SXpI0jZJ2yRtk/SQpG2StknaJmmbpIckbZO0TdI2SQ9J2iZp++cffuA0lVsMl9OGc1S2VLZUtlS2VD4zXE4bDipbKlsqWypbKrcbLp9SecTwFJUtlS2VLZUXMFxOG74RlS2VLZWt4fKBylcNj1PZUtlSuUvDu6GypQLDisqWypbKtzNcQOWE4UtUtlS2VLZUXtjwDqhsqXww3EhlS2VL5VsbXj+VLZXThk+p3OKfP/3EuzE8wx//8IckbZP0kKRtkrZJ2iZpm6SHJG2TtE3SNkkPSdomaZukbZK2SXpI0jZJ2yRtk/SQpG2StuH/VLZUPjWcprKlsqVyH4bXTGVL5UbDBypbKlsqr8Rwx1S2VLZUvmQ4QWVL5a0YXieVLZWVAVS2VLZUXpXhLqlsqWypPG74KpUtlbdl+BZUtlS2VJ5h2FJ5Z4Y7o7KlsqXylOERKlsqb9Hw+1LZUtlS2VI5DLdTeZeGu6GypbKlcs7wGZUtlbdr+L2obKlsqWypfGS4hco7NvxGVLZUtlS2VG4xfETl8rjh5alsqWypbKl8ZjhH5d0bnk1lS2VLZUvldsNB5fKU4SkqWypbKlsqWyqPGC6nDc+gsqWypbKlsjXAfw5cnjIP3CN54P4Mv3p44K4o/yP35WG4nDZcThsupw2X04bLacPltOFy2nA5bbicNlxOGy6nDZfThstpw+W04XLacDltuJw2/Eq5Rw/cmf8CC/IoVwHsCwIAAAAASUVORK5CYII=" /><p>Don&#39;t worry if you don&#39;t get the &quot;image&quot; result, that&#39;s expected and you&#39;ll learn how to automatically display an image later in JuliaImages.</p><p>Some add-on packages enable additional behavior. For example,</p><pre><code class="language-julia">using Unitful, AxisArrays
using Unitful: mm, s

img = AxisArray(rand(256, 256, 6, 50), (:x, :y, :z, :time), (0.4mm, 0.4mm, 1mm, 2s))</code></pre><p>defines a 4d image (3 space dimensions plus one time dimension) with the specified name and physical pixel spacing for each coordinate. The <a href="https://github.com/JuliaArrays/AxisArrays.jl"><code>AxisArrays</code></a> package supports rich and efficient operations on such arrays, and can be useful to keep track of not just pixel spacing but the <a href="http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm">orientation convention used for multidimensional images</a>.</p><p>JuliaImages interoperates smoothly with <code>AxisArrays</code> and many other packages.  As further examples,</p><ul><li><p>the <a href="https://github.com/JuliaImages/ImageMetadata.jl"><code>ImageMetadata</code></a> package (incorporated into <code>Images</code> itself) allows you to &quot;tag&quot; images with custom metadata</p></li><li><p>the <a href="https://github.com/JuliaArrays/IndirectArrays.jl"><code>IndirectArrays</code></a> package supports indexed (colormap) images</p></li><li><p>the <a href="https://github.com/JuliaArrays/MappedArrays.jl"><code>MappedArrays</code></a> package allows you to represent <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy</a> value-transformations, facilitating work with images that may be too large to store in memory at once</p></li><li><p><a href="https://github.com/JuliaImages/ImageTransformations.jl"><code>ImageTransformations</code></a> allows you to encode rotations, shears, deformations, etc., either eagerly or lazily</p></li></ul><p>It is very easy to define new array types in Julia–and consequently specialized images or operations–and have them interoperate smoothly with the vast majority of functions in JuliaImages.</p><h2 id="Array-elements-are-pixels-(and-vice-versa)"><a class="docs-heading-anchor" href="#Array-elements-are-pixels-(and-vice-versa)">Array elements are pixels (and vice versa)</a><a id="Array-elements-are-pixels-(and-vice-versa)-1"></a><a class="docs-heading-anchor-permalink" href="#Array-elements-are-pixels-(and-vice-versa)" title="Permalink"></a></h2><p>Elements of image are called <strong>pixels</strong>; in JuliaImages we provide an abstraction on this concept. For example, we have <code>Gray</code> for grayscale image, <code>RGB</code> for RGB image, <code>Lab</code> for Lab image, and etc.</p><p>Creating a pixel is initializing a struct of that type:</p><pre><code class="language-julia">Gray(0.0) # black
Gray(1.0) # white
RGB(1.0, 0.0, 0.0) # red
RGB(0.0, 1.0, 0.0) # green
RGB(0.0, 0.0, 1.0) # blue</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAAAtCAIAAADX+5viAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAI1JREFUeAHtwUENADAQw7BMKn/KNxp5xB4Od4fBewi8Q+EdAiNxG4nbSNxG4jYSt5G4jcRtJG4jcRuJ20jcRuI2EreRuI3EbSRuI3EbidtI3EbiNhK3kbiNxG0kbiNxG4nbSNxG4jYSt5G4jcRtJG4jcRuJ20jcRuI2EreRuI3EbSRuI3EbidtI3Ebi9gGrpQW02AG0cQAAAABJRU5ErkJggg==" /><p>and image is just an array of pixel objects:</p><pre><code class="language-julia-repl">julia&gt; img_gray = rand(Gray, 2, 2)
2×2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.355822)  Gray{Float64}(0.682579)
 Gray{Float64}(0.165132)  Gray{Float64}(0.806625)

julia&gt; img_rgb = rand(RGB, 2, 2)
2×2 Array{RGB{Float64},2} with eltype RGB{Float64}:
 RGB{Float64}(0.708011,0.515411,0.608607)   …  RGB{Float64}(0.34124,0.52376,0.661835)
 RGB{Float64}(0.887999,0.494824,0.0895199)     RGB{Float64}(0.833012,0.498856,0.937867)

julia&gt; img_lab = rand(Lab, 2, 2)
2×2 Array{Lab{Float64},2} with eltype Lab{Float64}:
 Lab{Float64}(95.6888,28.6177,-119.44)  …  Lab{Float64}(6.8166,-73.164,-82.2067)
 Lab{Float64}(68.5393,45.6552,50.4171)     Lab{Float64}(17.0987,-4.13231,93.5434)</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOYAAAAuCAIAAACzs/I1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAN5JREFUeAHtwSFOA1EARdFLeLo7YRMETTKZBDPLGEVSHBKFRqHqm7CNsWwDgYKELuIj+pp7TpZlYdg8zwybponz8PH8xrD36x3DDo8PnIerL/7B3QvDglQlSFWCVCVIVYJUJUhVglQlSFWCVCVIVYJUJUhVglQlSFWCVCVIVYJUJUhVglQlSFWCVCVIVbJtG8PWdeWC3PzsGfb0+8kF+Xu9Z9jt95FhQaoSpCpBqhKkKkGqEqQqQaoSpCpBqhKkKkGqEqQqQaoSpCpBqhKkKkGqEqQqQaoSpCpBqhKkKicxxhT8SBC/1AAAAABJRU5ErkJggg==" /><p>As you can see, both <code>img_rgb</code> and <code>img_lab</code> images are of size <span>$2 \times 2$</span> (instead of <span>$2 \times 2 \times 3$</span> or <span>$3 \times 2 \times 2$</span>); a RGB image is an array of <code>RGB</code> pixels whereas a Lab image is an array of <code>Lab</code> pixel.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It&#39;s recommended to use <code>Gray</code> instead of the <code>Number</code> type in JuliaImages since it indicates that the array of numbers is best interpreted as a grayscale image. For example, it triggers <code>Atom/Juno</code> and <code>Jupyter</code> to display the array as an image instead of a matrix of numbers. There&#39;s no performance overhead for using <code>Gray</code> over <code>Number</code>.</p></div></div><p>This design choice facilitates generic code that can handle both grayscale and color images without needing to introduce extra loops or checks for a color dimension. It also provides more rational support for 3d grayscale images–which might happen to have size 3 along the third dimension–and consequently helps unify the &quot;computer vision&quot; and &quot;biomedical image processing&quot; communities.</p><h2 id="Color-conversions-are-construction/view"><a class="docs-heading-anchor" href="#Color-conversions-are-construction/view">Color conversions are construction/view</a><a id="Color-conversions-are-construction/view-1"></a><a class="docs-heading-anchor-permalink" href="#Color-conversions-are-construction/view" title="Permalink"></a></h2><p>Conversions between different <code>Colorant</code>s are straightforward:</p><pre><code class="language-julia-repl">julia&gt; RGB.(img_gray) # Gray =&gt; RGB
2×2 Array{RGB{Float64},2} with eltype RGB{Float64}:
 RGB{Float64}(0.355822,0.355822,0.355822)  …  RGB{Float64}(0.682579,0.682579,0.682579)
 RGB{Float64}(0.165132,0.165132,0.165132)     RGB{Float64}(0.806625,0.806625,0.806625)

julia&gt; Gray.(img_rgb) # RGB =&gt; Gray
2×2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.583623)  Gray{Float64}(0.484927)
 Gray{Float64}(0.566179)  Gray{Float64}(0.648816)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You&#39;ll see <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting-1">broadcasting</a> semantics used in JuliaImages here and there, check the documentation if you&#39;re not familiar with it.</p></div></div><p>Sometimes, to work with other packages, you&#39;ll need to convert a <span>$m \times n$</span> <code>RGB</code> image to <span>$m \times n \times 3$</span> numeric array and vice versa. The functions <code>channelview</code> and <code>colorview</code> are designed for this purpose. For example:</p><pre><code class="language-julia-repl">julia&gt; img_CHW = channelview(img_rgb) # 3 * 2 * 2
3×2×2 reinterpret(reshape, Float64, ::Array{RGB{Float64},2}) with eltype Float64:
[:, :, 1] =
 0.708011  0.887999
 0.515411  0.494824
 0.608607  0.0895199

[:, :, 2] =
 0.34124   0.833012
 0.52376   0.498856
 0.661835  0.937867

julia&gt; img_HWC = permutedims(img_CHW, (2, 3, 1)) # 2 * 2 * 3
2×2×3 Array{Float64, 3}:
[:, :, 1] =
 0.708011  0.34124
 0.887999  0.833012

[:, :, 2] =
 0.515411  0.52376
 0.494824  0.498856

[:, :, 3] =
 0.608607   0.661835
 0.0895199  0.937867</code></pre><pre><code class="language-julia-repl">julia&gt; img_CHW = permutedims(img_HWC, (3, 1, 2)) # 3 * 2 * 2
3×2×2 Array{Float64, 3}:
[:, :, 1] =
 0.708011  0.887999
 0.515411  0.494824
 0.608607  0.0895199

[:, :, 2] =
 0.34124   0.833012
 0.52376   0.498856
 0.661835  0.937867

julia&gt; img_rgb = colorview(RGB, img_CHW) # 2 * 2
2×2 reinterpret(reshape, RGB{Float64}, ::Array{Float64, 3}) with eltype RGB{Float64}:
 RGB{Float64}(0.708011,0.515411,0.608607)   …  RGB{Float64}(0.34124,0.52376,0.661835)
 RGB{Float64}(0.887999,0.494824,0.0895199)     RGB{Float64}(0.833012,0.498856,0.937867)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Don&#39;t overuse <code>channelview</code> because it loses the colorant information by converting an image to a raw numeric array.</p><p>It&#39;s very likely that users from other languages will have the tendency to <code>channelview</code> every image they&#39;re going to process. Unfamiliarity of the pixel concept provided by JuliaImages doesn&#39;t necessarily mean it&#39;s bad.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The reason we use CHW (i.e., channel-height-width) order instead of HWC is that this provides a memory friendly indexing mechanisim for <code>Array</code>. By default, in Julia the first index is also the fastest (i.e., has adjacent storage in memory). For more details, please refer to the performance tip: <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Access-arrays-in-memory-order,-along-columns-1">Access arrays in memory order, along columns</a></p><p>You can use <code>PermutedDimsArray</code> to &quot;reinterpret&quot; the orientation of a chunk of memory without making a copy, or <code>permutedims</code> if you want a copy.</p></div></div><p>For <code>Gray</code> images, the following codes are almost equivalent except that the construction version copies the data while the view version doesn&#39;t.</p><pre><code class="language-julia">img_num = rand(4, 4)

img_gray_copy = Gray.(img_num) # construction
img_num_copy = Float64.(img_gray_copy) # construction

img_gray_view = colorview(Gray, img_num) # view
img_num_view = channelview(img_gray_view) # view</code></pre><h2 id="The-0-to-1-intensity-scale"><a class="docs-heading-anchor" href="#The-0-to-1-intensity-scale">The 0-to-1 intensity scale</a><a id="The-0-to-1-intensity-scale-1"></a><a class="docs-heading-anchor-permalink" href="#The-0-to-1-intensity-scale" title="Permalink"></a></h2><p>In JuliaImages, by default all images are displayed assuming that 0 means &quot;black&quot; and 1 means &quot;white&quot; or &quot;saturated&quot; (the latter applying to channels of an RGB image).</p><p>Perhaps surprisingly, <strong>this 0-to-1 convention applies even when the intensities are encoded using only 8-bits per color channel</strong>. JuliaImages uses a special type, <code>N0f8</code>, that interprets an 8-bit &quot;integer&quot; as if it had been scaled by 1/255, thus encoding values from 0 to 1 in 256 steps.</p><p><code>N0f8</code> numbers (standing for <strong>N</strong>ormalized, with <strong>0</strong> integer bits and <strong>8</strong> <strong>f</strong>ractional bits) obey standard mathematical rules, and can be added, multiplied, etc. There are types like <code>N0f16</code> for working with 16-bit images (and even <code>N2f14</code> for images acquired with a 14-bit camera, etc.).</p><pre><code class="language-julia-repl">julia&gt; img_n0f8 = rand(N0f8, 2, 2)
2×2 reinterpret(N0f8, ::Matrix{UInt8}):
 0.863  0.882
 0.275  0.071

julia&gt; float.(img_n0f8)
2×2 Matrix{Float32}:
 0.862745  0.882353
 0.27451   0.0705882</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This infrastructure allows us to unify &quot;integer&quot; and floating-point images, and avoids the need for special conversion functions (e.g., <code>im2double</code> in MATLAB) that change the <em>value</em> of pixels when your main goal is simply to change the <em>type</em> (numeric precision and properties) used to represent the pixel.</p></div></div><p>Although it&#39;s not recommended, but you can use <code>rawview</code> to get the underlying storage data and convert it to <code>UInt8</code> (or other types) if you insist.</p><pre><code class="language-julia-repl">julia&gt; img_n0f8_raw = rawview(img_n0f8)
2×2 rawview(reinterpret(N0f8, ::Matrix{UInt8})) with eltype UInt8:
 0xdc  0xe1
 0x46  0x12

julia&gt; float.(img_n0f8_raw)
2×2 Matrix{Float64}:
 220.0  225.0
  70.0   18.0</code></pre><p>Conversions between the storage type, i.e., the actual numeric type, without changing the color type are supported by the following functions:</p><ul><li><a href="../../function_reference/#ImageCore.float32"><code>float32</code></a>, <a href="../../function_reference/#ImageCore.float64"><code>float64</code></a></li><li><a href="../../function_reference/#ImageCore.n0f8"><code>n0f8</code></a>, <a href="../../function_reference/#ImageCore.n6f10"><code>n6f10</code></a>, <a href="../../function_reference/#ImageCore.n4f12"><code>n4f12</code></a>, <a href="../../function_reference/#ImageCore.n2f14"><code>n2f14</code></a>, <a href="../../function_reference/#ImageCore.n0f16"><code>n0f16</code></a></li></ul><pre><code class="language-julia-repl">julia&gt; img = rand(Gray{N0f8}, 2, 2)
2×2 Array{Gray{N0f8},2} with eltype Gray{N0f8}:
 Gray{N0f8}(0.745)  Gray{N0f8}(0.635)
 Gray{N0f8}(0.22)   Gray{N0f8}(0.0)

julia&gt; img_float32 = float32.(img) # Gray{N0f8} =&gt; Gray{Float32}
2×2 Array{Gray{Float32},2} with eltype Gray{Float32}:
 Gray{Float32}(0.745098)  Gray{Float32}(0.635294)
 Gray{Float32}(0.219608)  Gray{Float32}(0.0)

julia&gt; img_n0f16 = n0f16.(img_float32) # Gray{Float32} =&gt; Gray{N0f16}
2×2 Array{Gray{N0f16},2} with eltype Gray{N0f16}:
 Gray{N0f16}(0.7451)   Gray{N0f16}(0.63529)
 Gray{N0f16}(0.21961)  Gray{N0f16}(0.0)</code></pre><p>If you don&#39;t want to specify the destination type, <code>float</code> is designed for this:</p><pre><code class="language-julia-repl">julia&gt; img_n0f8 = rand(Gray{N0f8}, 2, 2)
2×2 Array{Gray{N0f8},2} with eltype Gray{N0f8}:
 Gray{N0f8}(0.804)  Gray{N0f8}(0.643)
 Gray{N0f8}(0.345)  Gray{N0f8}(0.298)

julia&gt; img_float = float.(img_n0f8) # Gray{N0f8} =&gt; Gray{Float32}
2×2 Array{Gray{Float32},2} with eltype Gray{Float32}:
 Gray{Float32}(0.803922)  Gray{Float32}(0.643137)
 Gray{Float32}(0.345098)  Gray{Float32}(0.298039)</code></pre><p>For a view-like conversion without new memory allocation, <code>of_eltype</code> in <a href="https://github.com/JuliaArrays/MappedArrays.jl"><code>MappedArrays</code></a> is designed for this:</p><pre><code class="language-julia-repl">julia&gt; using MappedArrays

julia&gt; img_float_view = of_eltype(Gray{Float32}, img_n0f8)
2×2 mappedarray(x-&gt;MappedArrays.convert($(Expr(:static_parameter, 1)), x), y-&gt;MappedArrays.convert($(Expr(:static_parameter, 1)), y), ::Array{Gray{N0f8},2}) with eltype Gray{Float32}:
 Gray{Float32}(0.803922)  Gray{Float32}(0.643137)
 Gray{Float32}(0.345098)  Gray{Float32}(0.298039)

julia&gt; eltype(img_float_view)
Gray{Float32}</code></pre><h2 id="Arrays-with-arbitrary-indices"><a class="docs-heading-anchor" href="#Arrays-with-arbitrary-indices">Arrays with arbitrary indices</a><a id="Arrays-with-arbitrary-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-with-arbitrary-indices" title="Permalink"></a></h2><p>If you have an input image and perform some kind of spatial transformation on it, how do pixels/voxels in the transformed image match up to pixels in the input? Through Julia&#39;s support for arrays with indices that start at values other than 1, it is possible to allow array indices to represent <em>absolute</em> position in space, making it straightforward to keep track of the correspondence between location across multiple images. More information can be found in <a href="../indexing/#Keeping-track-of-location-with-unconventional-indices">Keeping track of location with unconventional indices</a>.</p><h2 id="Function-categories"><a class="docs-heading-anchor" href="#Function-categories">Function categories</a><a id="Function-categories-1"></a><a class="docs-heading-anchor-permalink" href="#Function-categories" title="Permalink"></a></h2><p>See <a href="../../function_reference/#page_references">Summary and function reference</a> for more information about each of the topics below. The list below is accessible via <code>?Images</code> from the Julia REPL. If you&#39;ve used other frameworks previously, you may also be interested in the <a href="../../api_comparison/#page_api_comparison">Comparison with other image processing frameworks</a>. Also described are the <a href="../../pkgs/features/#ImageFeatures.jl">ImageFeatures.jl</a> and <a href="../../pkgs/segmentation/#ImageSegmentation.jl">ImageSegmentation.jl</a> packages, which support a number of algorithms important for computer vision.</p><p>Constructors, conversions, and traits:</p><ul><li>Construction: use constructors of specialized packages, e.g., <code>AxisArray</code>, <code>ImageMeta</code>, etc.</li><li>&quot;Conversion&quot;: <code>colorview</code>, <code>channelview</code>, <code>rawview</code>, <code>normedview</code>, <code>PermutedDimsArray</code>, <code>paddedviews</code></li><li>Traits: <code>pixelspacing</code>, <code>sdims</code>, <code>timeaxis</code>, <code>timedim</code>, <code>spacedirections</code></li></ul><p>Contrast/coloration:</p><ul><li><code>clamp01</code>, <code>clamp01nan</code>, <code>scaleminmax</code>, <code>colorsigned</code>, <code>scalesigned</code></li></ul><p>Algorithms:</p><ul><li>Reductions: <code>maxfinite</code>, <code>maxabsfinite</code>, <code>minfinite</code>, <code>meanfinite</code>, <code>sad</code>, <code>ssd</code>, <code>integral_image</code>, <code>boxdiff</code>, <code>gaussian_pyramid</code></li><li>Resizing and spatial transformations: <code>restrict</code>, <code>imresize</code>, <code>warp</code></li><li>Filtering: <code>imfilter</code>, <code>imfilter!</code>, <code>imfilter_LoG</code>, <code>mapwindow</code>, <code>imROF</code>, <code>padarray</code></li><li>Filtering kernels: <code>Kernel.</code> or <code>KernelFactors.</code>, followed by <code>ando[345]</code>, <code>guassian2d</code>, <code>imaverage</code>, <code>imdog</code>, <code>imlaplacian</code>, <code>prewitt</code>, <code>sobel</code></li><li>Exposure : <code>build_histogram</code>, <code>adjust_histogram</code>, <code>imadjustintensity</code>, <code>imstretch</code>, <code>imcomplement</code>, <code>AdaptiveEqualization</code>, <code>GammaCorrection</code>, <code>cliphist</code></li><li>Gradients: <code>backdiffx</code>, <code>backdiffy</code>, <code>forwarddiffx</code>, <code>forwarddiffy</code>, <code>imgradients</code></li><li>Edge detection: <code>imedge</code>, <code>imgradients</code>, <code>thin_edges</code>, <code>magnitude</code>, <code>phase</code>, <code>magnitudephase</code>, <code>orientation</code>, <code>canny</code></li><li>Corner detection: <code>imcorner</code>, <code>harris</code>, <code>shi_tomasi</code>, <code>kitchen_rosenfeld</code>, <code>meancovs</code>, <code>gammacovs</code>, <code>fastcorners</code></li><li>Blob detection: <code>blob_LoG</code>, <code>findlocalmaxima</code>, <code>findlocalminima</code></li><li>Morphological operations: <code>dilate</code>, <code>erode</code>, <code>closing</code>, <code>opening</code>, <code>tophat</code>, <code>bothat</code>, <code>morphogradient</code>, <code>morpholaplace</code>, <code>feature_transform</code>, <code>distance_transform</code></li><li>Connected components: <code>label_components</code>, <code>component_boxes</code>, <code>component_lengths</code>, <code>component_indices</code>, <code>component_subscripts</code>, <code>component_centroids</code></li><li>Interpolation: <code>bilinear_interpolation</code></li></ul><p>Test images and phantoms (see also TestImages.jl):</p><ul><li><code>shepp_logan</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../install/">« Getting started</a><a class="docs-footer-nextpage" href="../arrays_colors/">Arrays, Numbers, and Colors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 May 2021 09:20">Wednesday 5 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
